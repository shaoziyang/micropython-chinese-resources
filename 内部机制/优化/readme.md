# 优化

MicroPython 采用了多项优化措施，既节省内存（RAM），又能确保程序高效执行。本章将对其中部分优化措施进行探讨。

**注意**

- 关于`字符串驻留`（string interning）以及`映射与字典`（Maps and Dictionaries）的相关内容，详细介绍了针对字符串和字典的其他优化方式。


## 冻结字节码

当 MicroPython 从文件系统加载 Python 代码时，首先需要将文件解析为一种临时的内存中表示形式，随后再生成用于执行的字节码，这两个步骤产生的数据都会存储在堆内存（RAM）中，这一过程可能会占用大量内存。而通过 MicroPython 交叉编译器，可以生成一个包含 Python 模块预编译字节码的`.mpy`文件。该文件加载时仍会占用内存，但省去了代码解析阶段产生的额外内存开销。

作为一项进一步的优化措施，在固件编译过程中，可以将`.mpy`文件中的预编译字节码“冻结”到固件镜像中。这意味着后续执行字节码时，将直接从只读存储器（ROM）读取数据，不仅能显著节省内存，还可减少堆内存的碎片化问题。

有关更多信息，请参阅《MicroPython清单文件》（MicroPython manifest files）。


## 变量

MicroPython 对局部变量和全局变量的处理方式不同。全局变量存储在堆内存（RAM）上分配的全局字典中，并从中查找（注意：每个模块都有其独立的字典，因此拥有独立的命名空间）。与之不同的是，局部变量存储在 Python 值栈中，该值栈可能位于 C 语言栈或堆内存上。局部变量通过其在 Python 栈中的偏移量直接访问，这种方式比在字典中查找全局变量效率更高。

全局变量名的长度也会影响内存的使用量，因为标识符（即变量名）会存储在内存中。标识符越短，占用的内存就越少。

另一个需要注意的方面是：以下划线（`_`）开头的`const`变量会被视为真正的常量，不会在字典中分配空间或添加记录，从而节省部分内存。这些变量需使用 MicroPython 库中的`const()`函数定义。

因此，以下代码：
```python
from micropython import const
X = const(1)
_Y = const(2)
foo(X, _Y)
```

会被编译为：
```python
X = 1
foo(1, 2)
```


## 内存分配

MicroPython 中多数常用结构不会在堆内存（RAM）上分配空间，但以下结构除外：
- 列表、映射（如字典）等动态数据结构；
- 函数、类及对象实例；
- 导入（`import`）操作；
- 全局变量的首次赋值（需在全局字典中创建对应存储位置）。

如果需从更贴近用户的视角深入了解优化相关内容，可参阅《[最大化MicroPython速度](https://docs.micropython.org/en/latest/reference/speed_python.html)》（Maximising MicroPython speed）。



